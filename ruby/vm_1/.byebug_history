(exit)
ast[ip]
ast
continue
ast
continue
(exit)
node[1..-1].empty?
node[1..-1].nil?
node[1..-1]
node
(exit)
:apples[0..1]
:apples[0]
node[0]
exit
r
exit
args
arg1
exit
args
arg1
exit
obj
continue
args
meth
exit
node[ip]
exit
(quote apples)
'apples
ast
continue
exit
stack
word
continue
mem[word]
word
exit
continue
symbol_table
continue
symbol_table
continue
node
continue
code_ast
code
(exit)
code
exit
node
continue
node
continue
node
continue
node
continue
node
continue
node
continue
node
continue
node
continue
node
continue
node
exit
node
continue
node
exit
node[ip]
exit
opcodes.size
opcodes[219]
body_addr
opcodes[ip]
ip
result
stack
continue
node
continue
node
continue
node
exit
node
continue
node
op
continue
klass
exit
stack
INSTRUCTIONS['RBCC']
ip
args
exit
ip
bytecode
bytecode[ip+100]
bytecode[ip+1]
bytecode[ip-2]
0x91
0x90
bytecode[ip-1]
ip
args
meth
obj
exit
meth
obj
continue
obj
(exit)
meth
obj
exit
obj
meth
exit
node[ip-2]
node[ip-1]
ip
node[ip]
args
exit
meth
step 213
step end
step 3
step 2
step
meth
exit
stack
bytecode
arg_size_t
args
exit
arg_size_t
stack
args
(exit)
compile_node node[ip+1..-1].first
node[ip+1..-1].first
node[ip+1..-1]
compile_node node[ip+1..-1]
compile_node[ip+1..-1]
node[ip]
node
op
continue
op
exit
op
continue
op
symbol_table
func
exit
meth
continue
obj.send(meth, *args)
obj
meth
continue
meth
continue
exit
continue
exit
EOF
))))
        1
    (if (= n 0)
  (define (fact n)
SXP.read <<-EOF
continue
node
continue
node
exit
node
continue
SXP::Reader::Scheme.read stdlib
exit
SXP::Reader::Scheme.read stdlib
continue
(Array.wrap *args).push 2
Array.wrap *args
*args
args
klass
meth
continue
exit
args
meth
continue
(exit)
symbol_table
continue
ast
continue
def wtf(apples="ok")
def wtf(apples="ok") puts apples; end
def wtf(apples="ok"); puts apples; end
c.compile!(x, skip_hlt=true)
c.compile!(x, true)
x=SXP::Reader::Scheme.read(stdlib)
c.compile!(SXP::Reader::Scheme.read(stdlib), true)
c.compile! SXP::Reader::Scheme.read(stdlib), true
c=Compiler.new
c
c.compile!(SXP::Reader::Scheme.read(stdlib), true)
c.compile! SXP::Reader::Scheme.read(stdlib), true
c=Compiler.new
c.compile! SXP::Reader::Scheme.read(stdlib), true
SXP::Reader::Scheme.read(stdlib)
stdlib
continue
stack
return compile_bool(node)
node
exit
continue
ast
continue
src
(exit)
SXP::Reader::CommonLisp.read(src)
src="(t)"
SXP::Reader::CommonLisp.read(src)
src="t"
SXP::Reader::Scheme.read %q((and #t #f))
SXP::Reader::CommonLisp.read %q((or t nil)) 
SXP::Reader::CommonLisp.read(src)
src = "(if (= x t) (print \"ok\"))"
SXP::Reader::CommonLisp.read(src)
src = "(if (= x #\\t) (print \"ok\"))"
SXP::Reader::CommonLisp.read(src)
src = "(if (= x #//t) (print \"ok\"))"
SXP::Reader::CommonLisp.read(src)
src = "(if (= x #t) (print \"ok\"))"
src = "(if (= x #t) (print 
src = '#f'
